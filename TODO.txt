TODO:
first pass -> go over the lines -> add the data to the linked list, if there is a symbol add them to the symbol table 
-> if not data then you calculate the num of words needed allocate them in the array add the first word add the args needed.

get a line from the file 
strok where token is a space
check if first char is a dot
  -> check if rest of substring is "define"
check if last char is :
  -> check if substring until then is allowed to be a label
    -> turn symbol flag on
    -> use strtok again with space
check if first char is a dot
  -> check if it is for data(.data or .string)
    -> if symbol flag on then add the current dc with the symbol name into the symbol table
    -> symbol flag off
    -> check data type and enter them into the data linked list
  -> check if it is extern
    -> enter all operands into the symbol table as external with no value.
if flag on then add to symbol table with code attribute and val of IC+100 + strok to next space
check if it is an instruction
  -> analyze the operands
  -> calc L
  -> extend cmdTable by L
  -> add the needed words
  IC += L



method that checks if it is const line + add it
check if it a symbol definition
method that checks if it is an instruction line
add it if symbol flag on
check if external
check if entry

add it to the symbol flag on
method that checks if it is an operation line 

tommorow:
need method that checks if token is const
need method that checks if token is instruction returns its enum val
need method that checks if token is operation returns its opcode + operand count
need method that checks if is label
need method that checks if is valid label










































8 registers
memory size 4096
word size is always 14

first word in any command has the same structure in memory
2 bits for ARE field
2 bits for DEST addressing method
2 bits for SOURCE addressing method
3 bits for operating code
4 unused bits



addressing methods:
0 -> immediate addressing -> operand starts with # -> move #-1,r2
1 -> direct addressing -> operand is a var that has or will be defined -> dec x
2 -> constant index addressing -> operand will be a var followed by an index between squared brackets -> move x[2],r2
3 -> direct register addressing -> operand will be a register -> move r1,r2


operations that take two operands:
mov
cmp
add
sub
lea

operations that take one operand:
not
clr
inc
dec
jmp
bne
red
prn
jsr

operations that take no operands:
rts
hlt

macros:
mcr m_mcr
  inc r2
  mov A,r1
endmcr







seems to me we first create the first word for each.



so i only add all the data words in the second pass when i have everything







int DC = 0;
int IC = 0;
read line
check if define
  -> add to table
check if first word ends with :
  -> is definition = true
if .data or .string 
  -> if is definition
    -> add to table DC with tag
    -> add values to table and update DC
    
  



/*
get a line from the file
strok where token is a space
check if first char is a dot
  -> check if rest of substring is "define"
check if last char is :
  -> check if substring until then is allowed to be a label
    -> turn symbol flag on
    -> use strtok again with space
check if first char is a dot
  -> check if it is for data(.data or .string)
    -> if symbol flag on then add the current dc with the symbol name into the symbol table
    -> symbol flag off
    -> check data type and enter them into the data linked list
  -> check if it is extern
    -> enter all operands into the symbol table as external with no value.
if flag on then add to symbol table with code attribute and val of IC+100 + strok to next space
check if it is an instruction
  -> analyze the operands
  -> calc L
  -> extend cmdTable by L
  -> add the needed words
  IC += L

    char line[LINESIZE];
    instruction instruction
    char symbol[SYMBOL_MAX_SIZE+1];
    unsigned int index = 0;
    while (fgets(line, LINESIZE, fp) != EOF)
    {
        if (line[LINESIZE] != '\n') {
            // warning line too long max is LINESIZE
        }




        if(find_instruction(line) == DEFINE_IN) {
            int i = 0

            for(;line[index] && line[index] != ' '; index++);
            index++:
            MOVE_TO_NOT_WHITE(line, index);

            for(;line[index] && line[index] != ' ' && line[index != '=']; i++, index++) {
                symbol[i] = line[index];
            }

            symbol[i]='\0';

            MOVE_TO_NOT_WHITE(line, index);
            if (line[index] != '=') {
                // too long or missing...
            }
            index++;
            MOVE_TO_NOT_WHITE(line, index);
            // now all that should be left is the value and spaces...








            addSymbol(symbol, value, MDEFINE);
        }


        if (find_label(line)) {
            symbol = strtok(line, ":");
            token = strtok(NULL, ":");
            strcpy(line, token);
        }
        MOVE_TO_NOT_WHITE(line, index);
        if (line == NULL || line[index] == '\n') {
            // give warning about empty label and ignore
            return FALSE;
        }
        if (symbol =! NULL && !isValidSymbol(symbol)) {
            return FALSE;
        }
        instruction = find_instruction(line[index].instruction;

        if ((instruction == STRING_IN || instruction == DATA_IN) && symbol != NULL) {
            add_symbol(...);
        }

        switch(instruction) {
            case NONE_IN:
                // not found
            case STRING_IN:
                // add data

            case DATA_IN:
                // add data
            case EXTERN_IN:

            case ENTRY_IN:

        }


        process code line.
    }






   // TODO:
   // deadline: before end of week
   // finish entire first pass by sunday.
   // isValidSymbol(char symbol), find_instruction(char line),
   // defineHandler(), stringHandler(), dataHandler(), externHandler()

   int process_line(char *line, int line_num) {
    instruction instruction;
    char symbol[LINESIZE+1];
    unsigned int index = 0;

    if (find_label(line, &symbol)) {
        symbolHandler(line, symbol);
    }
    if (symbol[0] && !isValidSymbol(symbol)) {
        // error: invalid symbol name [name]
        return FALSE;
    }
    if (symbol[0]) {
        for(;line[index] != ':'; index++);
        index++;
    }

    MOVE_TO_NOT_WHITE(line, index);

    if (line[index] == '\n') return TRUE; // warning empty symbol: [name]


    if (findSymbol(symbol)) {
        // error: symbol [name] already exists
        return FALSE;
    }

    instruction = find_instruction(line[index]);

    if (instruction == DEFINE_IN && symbol[0] != '\0') {
        // error: define cannot have a symbol
        return FALSE;
    }
    if (instruction == ERROR_IN) {
        // error: line x: invalid instruction
        return FALSE;
    }

    if ((instruction == STRING_IN || instruction == DATA_IN) && symbol[0] != '\0') {
        addSymbol(symbol, DC, DATA);
    }
    if (instruction != NONE_IN) {
        for(;line[index] != ' ';index++);
        MOVE_TO_NOT_WHITE(line, index);
        switch(instruction) {
            case DEFINE_IN:
                defineHandler(line[index]);
                break;
            case STRING_IN:
                DC += stringHandler(line[index]);
                break;
            case DATA_IN:
                DC += dataHandler(line[index]);
                break;
            case EXTERN_IN:
                externHandler(line[index]);
                break;
            case ENTRY_IN:
                break;
        return TRUE;
        }
        if(symbol[0] != '\0') addSymbol(symbol, IC+RESERVED_STORAGE, CODE);
        return process_code(line[index], int line_num);

    }










































    switch(instruction) {
        case NONE_IN:
            break;
        case EXTERN_IN:

        case ENTRY_IN:

        default:
            instruction.command(line, index, dc);

    }
    if (instruction == NONE_IN) {

    }
    if (instruction.instruction == STRING_IN || instruction.instruction == DATA_IN)
    instruction.command()

     if(find_instruction(line) == DEFINE_IN) {
            methods:
            defineHandler(line);
            isInt();
            checkedStrtol();
            // would stop after this.
        }


   }




*/





int pre_process_line(char *line) {
  int index = 0;
  char first[LINESIZE+1];
  hashEntry *tmp;
  MOVE_TO_NOT_WHITE(line, index);
  if (is_end_of_line(line[index]) || line[index] == ';')
    {
        return FALSE;
    }
  while(!is_end_of_line(line[index]) && !isspace(line[index])) {
    first[i++] = line[index++];
  }
  first[i] = '\0';  
  MOVE_TO_NOT_WHITE(line, index);
  tmp = lookup(first);
  if (tmp != NULL) {
    if (!is_end_of_line(line[index])) {

    }
    
  }
}

